# Copyright 2020 Hewlett Packard Enterprise Development LP
---
- name: Configure CAN v2 on UANs
  block:

  - name: Get Customer Access Network info from SLS
    local_action:
      module: uri
      url: http://cray-sls/v1/search/networks?name=CAN
      method: GET
    register: sls_can

  - name: Set Customer Access Network CIDR from SLS, if network exists
    set_fact:
      customer_access_network: "{{ sls_can.json[0].ExtraProperties.Subnets[0].CIDR }}"
    when: sls_can.status == 200

  - name: Set Customer Access Network Gateway from SLS, if network exists
    set_fact:
      customer_access_gateway: "{{ sls_can.json[0].ExtraProperties.Subnets[0].Gateway }}"
    when: sls_can.status == 200

  - debug:
      msg: "No Customer Access Network defined, skipping CAN configuration."
    when:
      - customer_access_network is not defined
      - customer_access_gateway is not defined

  - name: Get Metal Network info from SLS
    local_action:
      module: uri
      url: http://cray-sls/v1/search/networks?name=Metal
      method: GET
    register: sls_mtl
    failed_when: sls_mtl.status != 200

  - name: Get Metal Management Network CIDR from SLS
    set_fact:
      metal_mgmt_cidr: "{{ sls_mtl.json[0].IPRanges[0] }}"

  - name: Get MTL network prefix
    set_fact:
      mtl_vlan1_prefix: "{{ metal_mgmt_cidr | ipaddr('prefix') }}"

  - name: Get NMN IP
    set_fact:
      nmn_ip: "{{ lookup('dig', ansible_hostname | regex_replace('(-nmn)$|(-can)$') + '-nmn.') }}"

  - name: Get last octet of NMN IP
    set_fact:
      octet: "{{ nmn_ip.split('.')[3] }}"

  # Uses the nth IP of the customer_access_network subnet where n is the last octet of the NMN IP
  - name: Get CAN IP
    set_fact:
        can_ip: "{{ customer_access_network | ipaddr(octet|int) | ipaddr('address') }}"

  - name: Get CAN Prefix
    set_fact:
        can_prefix: "{{ customer_access_network | ipaddr('prefix') }}"

  - name: Get customer_access_metallb_address_pool
    set_fact:
      customer_access_metallb_address_pool: "{{ sls_can.json[0].ExtraProperties.Subnets[1].CIDR }}"
    when: sls_can.status == 200

  - name: Get Mountain NMN Services Network info from SLS
    local_action:
      module: uri
      url: http://cray-sls/v1/search/networks?name=MNMN
      method: GET
    register: sls_mnmn_svcs

  - name: Set Mountain NMN Services CIDR from SLS, if network exists
    set_fact:
      mnmn_svcs_cidr: "{{ sls_mnmn_svcs.json[0].IPRanges[0] }}"
    when: sls_mnmn_svcs.status == 200

  - name: Get MTL IP
    set_fact:
      mtl_ip: "{{ lookup('dig', ansible_hostname | regex_replace('(-nmn)$|(-can)$') + '-mtl.') }}"

  - debug:
      msg: "NMN IP - {{ nmn_ip }}; CAN IP - {{ can_ip }}; MTL IP - {{ mtl_ip }}"

  - name: Get list of possible CAN interfaces
    shell: "ip -o link list | cut -f 2 -d ':' | tr -d ' ' | egrep -v 'lo|hsn|bond|vlan'"
    register: uan_device_list

  - name: Ensure list of possible CAN interfaces are UP
    shell: "ip link set dev {{ item }} up"
    register: cmd_out
    failed_when: cmd_out.rc not in [0, 1]
    loop: "{{ uan_device_list.stdout_lines }}"

  - name: List possible CAN intefaces
    debug:
      msg: "{{uan_device_list.stdout_lines }}"

  - name: Find the 40Gb devices
    shell: "ethtool {{ item }} | grep Speed | tr -d ' '"
    register: uan_device_speed
    loop: "{{ uan_device_list.stdout_lines }}"

  - name: Initialize list of uan_can_devices
    set_fact:
      uan_can_devices: []

  - name: Build list of uan_can_devices
    set_fact:
      uan_can_devices: "{{ uan_can_devices }} + ['{{ item.item }}']"
    when: item.stdout | regex_search('Speed:40000Mb')
    loop: "{{ uan_device_speed.results }}"

  - name: Set second CAN interface, if it is not connected
    set_fact:
      uan_2nd_can_ifname: "{{ item | regex_replace('(.+)(\\d+$)', '\\1') }}{{ item | regex_replace('(.+)(\\d+$)', '\\2') | int +1 }}"
    when: uan_can_devices | length == 1
    loop: "{{ uan_can_devices }}"

  - name: Add second CAN interface to uan_can_devices
    set_fact:
      uan_can_devices: "{{ uan_can_devices }} + ['{{ uan_2nd_can_ifname }}']"
    when: uan_can_devices | length == 1

  - name: List uan_can_devices
    debug:
      msg: "{{ uan_can_devices }}"

  - name: Configure bond slaves
    copy:
      src: ifcfg-bond-slaves
      dest: "/etc/sysconfig/network/ifcfg-{{ item }}"
      owner: root
      group: root
      mode: '0644'
    loop: "{{ uan_can_devices }}"

  - name: Configure ifcfg-bond0
    template:
      src: ifcfg-bond0.j2
      dest: /etc/sysconfig/network/ifcfg-bond0
      mode: 0644

  - name: Configure ifcfg-vlan007
    template:
      src: ifcfg-vlan007.j2
      dest: /etc/sysconfig/network/ifcfg-vlan007
      mode: 0644

  - name: Configure ifroute-vlan007
    template:
      src: ifroute-vlan007.j2
      dest: /etc/sysconfig/network/ifroute-vlan007
      owner: root
      mode: 0600

  - name: Ensure wicked script directories exist
    file:
      path: "/etc/wicked/scripts/{{ item }}"
      state: directory
    loop: [ "post-up", "post-down" ]

  - name: Configure can-up.sh
    template:
      src: can-up.j2
      dest: "/etc/wicked/scripts/post-up/can-up.sh"
      owner: root
      mode: 0755

  - name: Configure can-down.sh
    template:
      src: can-down.j2
      dest: "/etc/wicked/scripts/post-down/can-down.sh"
      owner: root
      mode: 0755

  - name: ifdown vlan007 and eth0 interfaces to set the interface config and routes
    shell: "wicked ifdown {{ item }}"
    changed_when: result.rc == 0
    failed_when: result.rc != 0
    register: result
    with_items:
      - eth0
      - vlan007

  - name: Wait 5 seconds for the interface to go down
    wait_for:
      timeout: 5

  - name: Restarting wicked-nanny
    shell: "systemctl restart wickedd-nanny"
    changed_when: result.rc == 0
    failed_when: result.rc != 0
    register: result

  - name: Wait 5 seconds for wickedd-nanny to restart
    wait_for:
      timeout: 5

  - name: Remove existing default route
    command: "ip route delete default"
    changed_when: result.rc != 0 or result.rc == 2
    failed_when: result.rc != 0 and result.rc != 2
    register: result

  - name: ifup vlan007 and eth0 interfaces to set the interface config and routes
    shell: "wicked ifup {{ item }}"
    changed_when: result.rc == 0
    failed_when: result.rc != 0
    register: result
    with_items:
      - vlan007
      - eth0

  - name: Wait 10 seconds for the interfaces to come up
    wait_for:
      timeout: 10

  - name: Check that we have the default route we are expecting
    shell: "ip route | grep default | grep -q '{{ customer_access_gateway }}'"
    failed_when: result.rc != 0
    register: result

  - name: Check that the vlan007 interface has the expected IP
    shell: "ip addr show vlan007 | grep -q {{ can_ip }}/{{ can_prefix }}"
    failed_when: result.rc != 0
    register: result

  when:
    - customer_access_network is defined
    - customer_access_gateway is defined

