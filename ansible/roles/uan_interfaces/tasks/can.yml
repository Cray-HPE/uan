#
# MIT License
#
# (C) Copyright 2020-2022 Hewlett Packard Enterprise Development LP
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
#
---
- name: "Get {{ uan_user_access_cfg | upper }} info from SLS"
  local_action:
    module: uri
    url: "http://cray-sls/v1/search/networks?name={{ uan_user_access_cfg | upper }}"
    method: GET
  register: sls_can
  failed_when: sls_can.status != 200
  run_once: true

- name: "Construct {{ uan_user_access_cfg | upper }} full names"
  set_fact:
    sls_can_fullname: "{{ uan_user_access_cfg | upper }} Bootstrap DHCP Subnet"
    sls_can_metallb: "{{ uan_user_access_cfg | upper }} Dynamic MetalLB"

- name: "Get {{ uan_user_access_cfg | upper }} Subnets"
  set_fact:
    can_subnets: "{{ item.ExtraProperties.Subnets }}"
  loop: "{{ sls_can.json }}"

- name: "Get {{ uan_user_access_cfg | upper }} CIDR from SLS, if network exists."
  set_fact:
    customer_access_ips: "{{ item.IPReservations }}"
    customer_access_network: "{{ item.CIDR }}"
    customer_access_gateway: "{{ item.Gateway }}"
    customer_access_vlan_id: "{{ item.VlanID }}"
  loop: "{{ can_subnets }}"
  when: item.FullName == sls_can_fullname

- name: "Get {{ uan_user_access_cfg | upper }} MetalLB CIDR from SLS, if network exists."
  set_fact:
    customer_access_network_metallb: "{{ item.CIDR }}"
  loop: "{{ can_subnets }}"
  when: item.FullName == sls_can_metallb

- name: "Setting {{ uan_user_access_cfg | upper }} name filter for Application"
  set_fact:
    customer_access_name: "{{ ansible_hostname }}"
  when: "'Application' in group_names"

- name: "Setting {{ uan_user_access_cfg | upper }} name filter for Compute"
  set_fact:
    customer_access_name: "{{ inventory_hostname + 'h0' }}"
  when: "'Compute' in group_names"

- name: "Get {{ uan_user_access_cfg | upper }} IP from SLS"
  set_fact:
    can_ip: "{{ item.IPAddress }}"
  loop: "{{ customer_access_ips }}"
  when: item.Name == customer_access_name

- name: "FAIL if {{ uan_user_access_cfg | upper }} IP is not defined"
  fail:
    msg: "{{ uan_user_access_cfg | upper }} IP is not defined for {{ customer_access_name }}"
  when: can_ip is not defined

- name: "FAIL if {{ uan_user_access_cfg | upper }} is not defined"
  fail:
    msg: "{{ uan_user_access_cfg | upper }} is not defined for the node, skipping {{ uan_user_access_cfg | upper }} configuration."
  when: (customer_access_network is not defined) or (customer_access_gateway is not defined)

- name: "Get {{ uan_user_access_cfg | upper }} Prefix"
  set_fact:
      can_prefix: "{{ customer_access_network | ipaddr('prefix') }}"

- name: Configure CAN interfaces
  block:

  - name: Get interface names for bond slave0
    shell: "ip a show {{ uan_can_bond_slaves[0] }} | head -n 1 | cut -f 2 -d ':' | cut -f 2 -d ' '"
    register: can_bond_slave0

  - name: Get interface names for bond slave1
    shell: "ip a show {{ uan_can_bond_slaves[1] }} | head -n 1 | cut -f 2 -d ':' | cut -f 2 -d ' '"
    register: can_bond_slave1

  - name: Ensure list of possible CAN interfaces are UP
    shell: "ip link set dev {{ item }} up"
    register: cmd_out
    failed_when: cmd_out.rc not in [0, 1]
    loop: "{{ uan_can_bond_slaves }}"

  - name: Configure bond slaves
    copy:
      src: ifcfg-bond-slaves
      dest: "/etc/sysconfig/network/ifcfg-{{ item }}"
      owner: root
      group: root
      mode: '0644'
    loop: 
      - "{{ can_bond_slave0.stdout }}"
      - "{{ can_bond_slave1.stdout }}"

  - name: Configure bond0
    template:
      src: ifcfg-bond0.j2
      dest: "/etc/sysconfig/network/ifcfg-bond0"
      owner: root
      group: root
      mode: '0644'

  - name: Configure ifcfg-can0
    template:
      src: ifcfg-can0.j2
      dest: /etc/sysconfig/network/ifcfg-can0
      mode: 0644

  - name: Configure ifroute-can0
    template:
      src: ifroute-customer_access.j2
      dest: /etc/sysconfig/network/ifroute-can0
      owner: root
      mode: 0600

  - name: Setup ifroute-can0 for MetalLB services
    lineinfile:
      dest: /etc/sysconfig/network/ifroute-can0
      state: present
      regex: "{{ customer_access_network_metallb | ipaddr('network') }} {{ customer_access_gateway }} {{ customer_access_network_metallb | ipaddr('netmask') }} -"
      line: "{{ customer_access_network_metallb | ipaddr('network') }} {{ customer_access_gateway }} {{ customer_access_network_metallb | ipaddr('netmask') }} -"

  - name: Set list of interfaces to restart for CAN
    set_fact:
      uan_interface: "can0"

  when:
    - (uan_user_access_cfg | upper) == "CAN"
    - "'Compute' not in group_names"

- name: Configure CHN interface
  block:

  - name: Get list of possible CHN interfaces
    shell: "ip -o link list | cut -f 2 -d ':' | tr -d ' ' | sort | egrep 'hsn'"
    register: chn_device_list

  - name: FAIL if no customer access interfaces are found
    fail:
      msg: "No Customer Access interfaces found"
    when: chn_device_list.stdout_lines | length < 1

  - name: Ensure list of possible CHN interfaces are UP
    shell: "ip link set dev {{ chn_device_list.stdout_lines | first }} up"
    register: cmd_out
    failed_when: cmd_out.rc not in [0, 1]

  - name: "List possible {{ uan_user_access_cfg | upper }} interfaces"
    debug:
      msg: "{{chn_device_list.stdout_lines }}"

  - name: "Determine if ifcfg-{{ chn_device_list.stdout_lines | first }} exists"
    stat:
      path: "/etc/sysconfig/network/ifcfg-{{ chn_device_list.stdout_lines | first }}"
    register: ifcfg_chn

  - name: "Determine if ifroute-{{ chn_device_list.stdout_lines | first }} exists"
    stat:
      path: "/etc/sysconfig/network/ifroute-{{ chn_device_list.stdout_lines | first }}"
    register: ifroute_chn
    
  - name: "Add CHN IP to {{ chn_device_list.stdout_lines | first }} if no ifcfg file exists"
    when: (can_ip is defined) and (not ifcfg_chn.stat.exists)
    shell: "ip address add {{ can_ip }}/{{ can_prefix }} dev {{ chn_device_list.stdout_lines | first }}"
    register: cmd_out
    failed_when: cmd_out.rc not in [0, 1, 2]

  - name: "Add static route for {{ customer_access_gateway }} if no ifroute file exists"
    when:
      - can_ip is defined
      - not ifroute_chn.stat.exists
    shell: "ip route add {{ customer_access_network }} dev {{ chn_device_list.stdout_lines | first }} src {{ can_ip }}"
    register: cmd_out
    failed_when: cmd_out.rc not in [0, 1, 2]

  - name: "Add static route for {{ customer_access_gateway }} MetalLB services if no ifroute file exists"
    when:
      - can_ip is defined
      - not ifroute_chn.stat.exists
    shell: "ip route add {{ customer_access_network_metallb }} via {{ customer_access_gateway }} dev {{ chn_device_list.stdout_lines | first }}"
    register: cmd_out
    failed_when: cmd_out.rc not in [0, 1, 2]

  - name: "Set default route for {{ customer_access_gateway }} if no ifroute file exists"
    when:
      - can_ip is defined
      - not ifroute_chn.stat.exists
    shell: "ip route add default via {{ customer_access_gateway }} dev {{ chn_device_list.stdout_lines | first }}"
    register: cmd_out
    failed_when: cmd_out.rc not in [0, 1, 2]

  - name: Set IPADDR1 entry for CHN if ifcfg file exists
    when:
      - can_ip is defined
      - ifcfg_chn.stat.exists
    lineinfile:
      dest: "/etc/sysconfig/network/ifcfg-{{ chn_device_list.stdout_lines | first }}"
      regex: '^IPADDR1=(.*)$'
      line: "IPADDR1={{ can_ip }}/{{ can_prefix }}"

  - name: "Setup ifroute-{{ chn_device_list.stdout_lines | first }} default if ifroute file exists"
    when:
      - can_ip is defined
      - ifroute_chn.stat.exists
    lineinfile:
      dest: "/etc/sysconfig/network/ifroute-{{ chn_device_list.stdout_lines | first }}"
      state: present
      regex: "default {{ customer_access_gateway }} - -"
      line: "default {{ customer_access_gateway }} - -"

  - name: "Setup ifroute-{{ chn_device_list.stdout_lines | first }} for MetalLB services if ifroute exists"
    when:
      - can_ip is defined
      - ifroute_chn.stat.exists
    lineinfile:
      dest: "/etc/sysconfig/network/ifroute-{{ chn_device_list.stdout_lines | first }}"
      state: present
      regex: "{{ customer_access_network_metallb | ipaddr('network') }} {{ customer_access_gateway }} {{ customer_access_network_metallb | ipaddr('netmask') }} -"
      line: "{{ customer_access_network_metallb | ipaddr('network') }} {{ customer_access_gateway }} {{ customer_access_network_metallb | ipaddr('netmask') }} -"

  - name: Set list of interfaces to restart for CHN
    set_fact:
      uan_interface: "{{ chn_device_list.stdout_lines | first }}"

  when: 
    - (uan_user_access_cfg | upper) == "CHN"

- name: Reloading wicked to set new routes
  when: (((uan_user_access_cfg | upper) == "CHN") and ifcfg_chn.stat.exists)  or (uan_user_access_cfg | upper) == "CAN"
  shell: "systemctl reload wicked;sleep 5"
  changed_when: result.rc == 0
  failed_when: result.rc != 0
  register: result

- name: Restarting wicked-nanny
  when: (((uan_user_access_cfg | upper) == "CHN") and ifcfg_chn.stat.exists)  or (uan_user_access_cfg | upper) == "CAN"
  shell: "systemctl restart wickedd-nanny;sleep 5"
  changed_when: result.rc == 0
  failed_when: result.rc != 0
  register: result

- name: Remove existing default route
  when: (((uan_user_access_cfg | upper) == "CHN") and ifroute_chn.stat.exists)  or (uan_user_access_cfg | upper) == "CAN"
  command: "ip route delete default"
  changed_when: result.rc != 0 or result.rc == 2
  failed_when: result.rc != 0 and result.rc != 2
  register: result

- name: Reload networks to update default route 
  when: (((uan_user_access_cfg | upper) == "CHN") and ifcfg_chn.stat.exists)  or (uan_user_access_cfg | upper) == "CAN"
  shell: "systemctl reload wicked;sleep 5"
  changed_when: result.rc == 0
  failed_when: result.rc != 0
  register: result

- name: Restarting wicked-nanny
  when: (((uan_user_access_cfg | upper) == "CHN") and ifcfg_chn.stat.exists)  or (uan_user_access_cfg | upper) == "CAN"
  shell: "systemctl restart wickedd-nanny;sleep 5"
  changed_when: result.rc == 0
  failed_when: result.rc != 0
  register: result

- name: Check that we have the default route we are expecting
  when: not uan_customer_default_route | bool
  shell: "ip route | grep default | grep -q '{{ customer_access_gateway }}'"
  failed_when: result.rc != 0
  register: result

- name: "Check that the {{ uan_interface }} interface has the expected IP"
  shell: "ip addr show {{ uan_interface }} | grep -q {{ can_ip }}/{{ can_prefix }}"
  failed_when: result.rc != 0
  register: result
  when: can_ip is defined
